package hypocert

import (
	"errors"
	"fmt"
	"math"
	"math/big"
	"paillier"
	"sync"
)

//////////////////////////////////////////
// Constants and Caches

// pre-computed solved bits for faster on-line phase
var solvedBits [][]*paillier.Ciphertext
var solvedBitsValue []*paillier.Ciphertext

var nextSolvedBitsIndex = 0

// store lagrange polynomials to avoid recalculations
var funcORCoefficientCache sync.Map
var funcXORCoefficientCache sync.Map

// set/propagate/kill wrapper used in the
// EBitsCarries protocol
type spk struct {
	s, p, k *paillier.Ciphertext
}

//////////////////////////////////////////

// RandomMultShare returns a random encrypted integer and c*r
// in {1...Pk.N}, jointly generated by all parties
func (mpc *MPC) RandomMultShare(c *paillier.Ciphertext) (*paillier.Ciphertext, *paillier.Ciphertext) {

	shares := make([]*paillier.Ciphertext, len(mpc.Parties))
	sharesMult := make([]*paillier.Ciphertext, len(mpc.Parties))

	var wg sync.WaitGroup

	for i := 0; i < len(mpc.Parties); i++ {

		wg.Add(1)

		go func(i int) {
			defer wg.Done()

			share, mult := mpc.Parties[i].GetRandomMultShare(c)
			shares[i] = share

			sharesMult[i] = mult
		}(i)
	}

	wg.Wait()

	shareSum := mpc.Pk.EncryptInt(big.NewInt(0))
	shareMult := mpc.Pk.EncryptInt(big.NewInt(0))

	for i := 0; i < len(mpc.Parties); i++ {
		shareSum = mpc.Pk.EAdd(shareSum, shares[i])
		shareMult = mpc.Pk.EAdd(shareMult, sharesMult[i])
	}

	return shareSum, shareMult
}

// RandomShare returns a random encrypted integer
// in {1...Pk.T}, jointly generated by all parties
func (mpc *MPC) RandomShare(bound *big.Int) *paillier.Ciphertext {

	shares := make([]*paillier.Ciphertext, len(mpc.Parties))

	var wg sync.WaitGroup
	for i := 0; i < len(mpc.Parties); i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			share := mpc.Parties[i].GetRandomShare(bound)
			shares[i] = share
		}(i)
	}

	wg.Wait()

	shareSum := mpc.Pk.EncryptInt(big.NewInt(0))
	for i := 0; i < len(mpc.Parties); i++ {
		shareSum = mpc.Pk.EAdd(shareSum, shares[i])
	}

	return shareSum
}

// RandomInvertibleShare returns a random encrypted integer
// in {1...Pk.T} and its inverse (mod Pk.N)
func (mpc *MPC) RandomInvertibleShare() (*paillier.Ciphertext, *paillier.Ciphertext, error) {

	a := mpc.RandomShare(mpc.Pk.N)
	b := mpc.RandomShare(mpc.Pk.N)
	c := mpc.RevealInt(mpc.EMult(a, b))

	if c.Int64() == 0 {
		return nil, nil, errors.New("abort")
	}

	cInv := big.NewInt(0).ModInverse(c, mpc.Pk.N)
	aInv := mpc.Pk.ECMult(b, cInv)

	return a, aInv, nil
}

// RandomBit returns a random bit from {0,1}
func (mpc *MPC) RandomBit() (*paillier.Ciphertext, error) {

	// // fmt.Println("[DEBUG]:  RandomBit()")

	// r := mpc.RandomShare()
	// a := mpc.RevealInt(mpc.EMult(r, r))

	// // make sure inverse exists
	// if a.Int64() == 0 {
	// 	return nil, errors.New("abort")
	// }

	// b := big.NewInt(0).ModSqrt(a, mpc.Pk.T)
	// //fmt.Println("sqrt(a) is: " + b.String())

	// bInv := big.NewInt(0).ModInverse(b, mpc.Pk.T) // find b^-1 mod N

	// twoInv = big.NewInt(0).ModInverse(big.NewInt(2), mpc.Pk.T) // find 2^-1 mod N

	// c := mpc.Pk.ECMult(r, bInv)
	// c = mpc.Pk.EAdd(c, mpc.Pk.EncryptInt(big.NewInt(1)))
	// c = mpc.Pk.ECMult(c, twoInv)

	c := newCryptoRandom(big.NewInt(2))

	return mpc.Pk.EncryptInt(c), nil
}

// solvedBits returns a random bit string from {0,1}^m and the corresponding
func (mpc *MPC) solvedBits(m int) ([]*paillier.Ciphertext, *paillier.Ciphertext, error) {

	bits := make([]*paillier.Ciphertext, m)

	var wg sync.WaitGroup

	for i := 0; i < m; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			bit, err := mpc.RandomBit()
			for err != nil {
				fmt.Println("[DEBUG]: RandomBit() aborted.")
				err = nil
				bit, err = mpc.RandomBit()
			}
			bits[i] = bit
		}(i)
	}

	wg.Wait()

	// convert bits to an encrypted integer
	val := mpc.EBitsToEInteger(bits, false)

	return bits, val, nil
}

//EBitsExp returns 2^x where x = integer(bits)
func (mpc *MPC) EBitsExp(bits []*paillier.Ciphertext) *paillier.Ciphertext {

	base := big.NewInt(2)
	one := mpc.Pk.EncryptInt(big.NewInt(1))
	res := mpc.Pk.EncryptInt(big.NewInt(1))

	for i := 0; i < len(bits); i++ {

		pow := mpc.Pk.ECMult(bits[i], base)
		t1 := mpc.EMult(res, pow)
		t2 := mpc.EMult(mpc.Pk.ESub(one, bits[i]), one)
		t2 = mpc.EMult(t2, res)
		res = mpc.Pk.EAdd(t1, t2)
		base = base.Exp(base, big.NewInt(2), mpc.Pk.T)
	}
	return res
}

//EBitsMult returns the bitwise sharing of a*b (note: a*b < pk.T)
func (mpc *MPC) EBitsMult(a, b []*paillier.Ciphertext) []*paillier.Ciphertext {

	length := len(a) + 1
	l2 := int(math.Floor(float64(length) / 2.0))

	resBits := make([]*paillier.Ciphertext, length)
	partialSum := make([]*paillier.Ciphertext, length)

	zero := mpc.Pk.EncryptInt(big.NewInt(0))
	for i := 0; i < length; i++ {
		partialSum[i] = zero
		resBits[i] = zero
	}

	for i := l2; i >= 0; i-- {
		for k := l2; k >= 0; k-- {
			c := mpc.EMult(a[i], b[k])
			partialSum[i+k] = c
		}

		if i == l2 {
			resBits = partialSum
		} else {
			resBits = mpc.EBitsADD(resBits, partialSum)
			resBits = resBits[0:mpc.Pk.T.BitLen()]
		}
	}

	return resBits[0:mpc.Pk.T.BitLen()]

}

//EBitsToEInteger returns the integer (in Zn) representation of an encrypted binary string
func (mpc *MPC) EBitsToEInteger(bits []*paillier.Ciphertext, l2 bool) *paillier.Ciphertext {

	if l2 {
		acc := mpc.Pk.EncryptInt(big.NewInt(0))
		base := big.NewInt(2)
		for i := len(bits) - 1; i >= 0; i-- {
			acc = mpc.Pk.ECMult(acc, base)
			acc = mpc.Pk.EAdd(acc, bits[i])
		}
		return acc

	}

	acc := mpc.Pk.EncryptInt(big.NewInt(0))
	base := big.NewInt(2)
	for i := len(bits) - 1; i >= 0; i-- {
		acc = mpc.Pk.ECMult(acc, base)
		acc = mpc.Pk.EAdd(acc, bits[i])
	}
	return acc
}

// EIntegerToEBits returns a bit representation of an integer in {0...T}
func (mpc *MPC) EIntegerToEBits(a *paillier.Ciphertext) []*paillier.Ciphertext {

	n := mpc.Pk.T.BitLen() + 1
	// max value in integers < T
	maxValue := big.NewInt(0).Exp(big.NewInt(2), big.NewInt(int64(n+1)), nil)

	// max value in encrypted dummy bit form
	maxEBits := mpc.EBitsBigEndian(mpc.Pk.T, n)

	// diff 2^log(T) - T note that this is a positive quantity
	deltaBits := mpc.BitsBigEndian(big.NewInt(0).Sub(maxValue, mpc.Pk.T), n)

	// get solved bits
	solvedBits, d, err := mpc.solvedBits(mpc.Pk.K)
	for err != nil {
		solvedBits, d, err = mpc.solvedBits(mpc.Pk.K)
	}

	// compute a-d where d is the integer returned from solvedbits
	rev := mpc.RevealInt(mpc.Pk.ESub(a, d))

	// if negative, adjust to be correct mod pk.T
	if rev.Cmp(big.NewInt(0).Div(mpc.Pk.N, big.NewInt(2))) > 0 {
		rev = big.NewInt(0).Sub(rev, mpc.Pk.N)
		rev = big.NewInt(0).Add(mpc.Pk.T, rev)
	}

	revBits := mpc.EBitsBigEndian(rev, n)
	sumBits := mpc.EBitsADD(revBits, solvedBits)
	sumBits = sumBits[0 : len(sumBits)-1]

	q := mpc.EBitsLT(maxEBits, sumBits)
	g := make([]*paillier.Ciphertext, n)

	for i := 0; i < n; i++ {
		g[i] = mpc.Pk.ECMult(q, deltaBits[i])
	}

	h := mpc.EBitsADD(sumBits, g)

	// drop the two most significant bits to correct error
	// see paper for details
	return h[0:mpc.Pk.T.BitLen()]
}

// EFanInMULT efficiently computes [x,x^2,x^3...x^n] where n = len(elements)
// Note: can be used as a PrefixAND when elements are binary
func (mpc *MPC) EFanInMULT(elements []*paillier.Ciphertext) []*paillier.Ciphertext {

	n := len(elements)
	res := make([]*paillier.Ciphertext, n)
	res[0] = elements[0]

	if n == 1 {
		return res
	}

	shares := make([]*paillier.Ciphertext, n+1)
	sharesInv := make([]*paillier.Ciphertext, n+1)

	var wg sync.WaitGroup
	for i := 0; i < n+1; i++ {
		wg.Add(1)

		go func(i int) {
			defer wg.Done()
			var err error
			shares[i], sharesInv[i], err = mpc.RandomInvertibleShare()
			for err != nil {
				shares[i], sharesInv[i], err = mpc.RandomInvertibleShare()

			}
		}(i)
	}

	wg.Wait()

	d := make([]*big.Int, n+1)

	for i := 0; i < n; i++ {
		c := mpc.EMult(shares[i], elements[i])
		c = mpc.EMult(c, sharesInv[i+1])
		d[i] = mpc.RevealInt(c)
	}

	powerMultInv := mpc.Pk.EncryptInt(big.NewInt(1))
	for i := 0; i < n; i++ {

		c := mpc.EMult(sharesInv[i], shares[i+1])
		c = mpc.Pk.ECMult(c, d[i])
		powerMultInv = mpc.EMult(c, powerMultInv)

		res[i] = powerMultInv

	}
	return res
}

// EBitsOR computes the OR of all the bits
func (mpc *MPC) EBitsOR(bits []*paillier.Ciphertext) *paillier.Ciphertext {

	//fmt.Println("[DEBUG]:  EBitsOR()")

	n := len(bits)

	sum := mpc.Pk.EncryptInt(big.NewInt(1))
	for i := 0; i < n; i++ {
		sum = mpc.Pk.EAdd(sum, bits[i])
	}

	a := make([]*paillier.Ciphertext, n+1)
	for i := 0; i <= n; i++ {
		a[i] = sum
	}

	mul := mpc.EFanInMULT(a)
	a = mul

	poly := funcORInterpolation(n, mpc.Pk.N)
	res := mpc.Pk.EncryptInt(poly[n])
	for i := 1; i <= n; i++ {
		c := mpc.Pk.ECMult(a[i-1], poly[n-i])
		res = mpc.Pk.EAdd(res, c)
	}

	return res
}

// EBitsXOR computes the XOR of all the bits
func (mpc *MPC) EBitsXOR(bits []*paillier.Ciphertext) *paillier.Ciphertext {

	n := len(bits)

	sum := mpc.Pk.EncryptInt(big.NewInt(1))
	for i := 0; i < n; i++ {
		sum = mpc.Pk.EAdd(sum, bits[i])
	}

	a := make([]*paillier.Ciphertext, n+1)
	for i := 0; i <= n; i++ {
		a[i] = sum
	}

	mul := mpc.EFanInMULT(a)

	poly := funcXORInterpolation(n, mpc.Pk.N)
	res := mpc.Pk.EncryptInt(poly[n])
	for i := 1; i <= n; i++ {
		c := mpc.Pk.ECMult(mul[i-1], poly[n-i])
		res = mpc.Pk.EAdd(res, c)
	}

	return res
}

// EBitsAND computes the AND of all the bits
func (mpc *MPC) EBitsAND(bits []*paillier.Ciphertext) *paillier.Ciphertext {

	//fmt.Println("[DEBUG]:  EBitsAND()")

	degree := len(bits)

	res := bits[0]
	for i := 1; i < degree; i++ {
		res = mpc.EMult(res, bits[i])
	}

	return res
}

func (mpc *MPC) EBitsPrefixOR(bits []*paillier.Ciphertext) []*paillier.Ciphertext {

	//fmt.Println("[DEBUG]:  EBitsPrefixOR()")

	degree := len(bits)

	// find the nearest square to len(bits)
	lambda := int(math.Ceil(math.Sqrt(float64(len(bits)))))
	zero := mpc.Pk.EncryptInt(big.NewInt(0))

	diff := lambda*lambda - len(bits)
	for i := 0; i < diff; i++ {
		bits = append(bits, zero)
	}

	var wg sync.WaitGroup
	// Compute Row wise OR of elements in A
	rowOr := make([]*paillier.Ciphertext, lambda)
	for i := 0; i < lambda; i++ {
		wg.Add(1)
		row := make([]*paillier.Ciphertext, lambda)
		for j := 0; j < lambda; j++ {
			row[j] = bits[i*lambda+j]
		}

		go func(i int, row []*paillier.Ciphertext) {
			defer wg.Done()

			res := mpc.EBitsOR(row)
			rowOr[i] = res

		}(i, row)
	}

	wg.Wait()

	// Compute ORs of Xis
	rowRes := make([]*paillier.Ciphertext, lambda)
	rowRes[0] = rowOr[0]

	wg.Add(lambda - 1)
	for n := 1; n < lambda; n++ {

		row := make([]*paillier.Ciphertext, n+1)
		for i := 0; i <= n; i++ {
			row[i] = rowOr[i]
		}

		go func(n int, row []*paillier.Ciphertext) {
			defer wg.Done()

			res := mpc.EBitsOR(row)
			rowRes[n] = res

		}(n, row)
	}

	wg.Wait()

	f := make([]*paillier.Ciphertext, lambda)
	f[0] = rowOr[0]
	for i := 1; i < lambda; i++ {
		f[i] = mpc.Pk.ESub(rowRes[i], rowRes[i-1])
	}

	g := make([]*paillier.Ciphertext, lambda)
	for j := 0; j < lambda; j++ {
		sum := zero
		for i := 0; i < lambda; i++ {
			sum = mpc.Pk.EAdd(sum, mpc.EMult(bits[i*lambda+j], f[i]))
		}
		g[j] = sum
	}

	// Compute PrefixOr of ci
	b := make([]*paillier.Ciphertext, lambda)
	b[0] = g[0]

	wg.Add(lambda - 1)
	for n := 1; n < lambda; n++ {

		row := make([]*paillier.Ciphertext, n+1)
		for i := 0; i <= n; i++ {
			row[i] = g[i]
		}

		go func(n int, row []*paillier.Ciphertext) {
			defer wg.Done()

			res := mpc.EBitsOR(row)
			b[n] = res

		}(n, row)
	}

	wg.Wait()

	s := make([]*paillier.Ciphertext, lambda)
	for i := 0; i < lambda; i++ {
		s[i] = mpc.Pk.ESub(rowRes[i], f[i])
	}

	result := make([]*paillier.Ciphertext, lambda*lambda)
	for i := 0; i < lambda; i++ {
		for j := 0; j < lambda; j++ {

			if lambda*i+j >= degree {
				break
			}

			sum := mpc.EMult(b[j], f[i])
			sum = mpc.Pk.EAdd(sum, s[i])

			res := sum

			result[i*lambda+j] = res
		}
	}

	return result[0:degree]
}

func (mpc *MPC) EBitsPrefixSPK(bits []*spk) []*spk {

	degree := len(bits)

	var wg sync.WaitGroup
	wg.Add(degree)

	res := make([]*spk, degree)
	for i := 0; i < degree; i++ {
		go func(i int) {
			defer wg.Done()

			row := make([]*spk, i+1)
			for k := 0; k <= i; k++ {
				row[k] = bits[k]
			}

			spk := mpc.EBitsSPK(row)
			res[i] = spk

		}(i)
	}

	wg.Wait()

	return res
}

func (mpc *MPC) EBitNOT(b *paillier.Ciphertext) *paillier.Ciphertext {
	return mpc.Pk.ESub(mpc.Pk.EncryptInt(big.NewInt(1)), b)
}

// EBitsADD outputs the bitwise representation of a+b
func (mpc *MPC) EBitsSUB(a, b []*paillier.Ciphertext) []*paillier.Ciphertext {

	if len(a) < len(b) {
		a = mpc.makeEqualLength(a, b)
	} else {
		b = mpc.makeEqualLength(b, a)
	}

	degree := len(a)

	sum := make([]*paillier.Ciphertext, degree)

	borrow := mpc.Pk.ESub(a[0], b[0])
	sum[0] = mpc.EMult(borrow, borrow)

	for i := 1; i < degree; i++ {
		sum[i] = mpc.EMult(borrow, borrow)
		q := mpc.EMult(a[i], mpc.Pk.EAdd(a[i], borrow))
		borrow = mpc.Pk.ESub(q, b[i])
	}

	return sum
}

// EBitsADD outputs the bitwise representation of a+b
func (mpc *MPC) EBitsADD(a, b []*paillier.Ciphertext) []*paillier.Ciphertext {

	if len(a) < len(b) {
		a = mpc.makeEqualLength(a, b)
	} else {
		b = mpc.makeEqualLength(b, a)
	}

	degree := len(a)
	carries := mpc.EBitsCarries(a, b)

	sum := make([]*paillier.Ciphertext, degree+1)
	lsb := mpc.Pk.EAdd(a[0], b[0])
	lsb = mpc.Pk.ESub(lsb, mpc.Pk.ECMult(carries[0], big.NewInt(2)))
	sum[0] = lsb
	sum[degree] = carries[degree-1]

	for i := 1; i < degree; i++ {
		sum[i] = mpc.Pk.EAdd(a[i], b[i])
		sum[i] = mpc.Pk.EAdd(sum[i], carries[i-1])
		sum[i] = mpc.Pk.ESub(sum[i], mpc.Pk.ECMult(carries[i], big.NewInt(2)))
	}

	return sum
}

// EBitsLT returns [0] if a > b, [1] otherwise
func (mpc *MPC) EBitsLT(a, b []*paillier.Ciphertext) *paillier.Ciphertext {

	//fmt.Println("[DEBUG]:  EBitsLessThan()")

	if len(a) < len(b) {
		a = mpc.makeEqualLength(a, b)
	} else {
		b = mpc.makeEqualLength(b, a)
	}

	degree := len(a) // len(a) = len(b) now
	e := make([]*paillier.Ciphertext, degree)

	for i := 0; i < degree; i++ {
		d := mpc.Pk.ESub(a[i], b[i])
		d2 := mpc.EMult(d, d)
		e[degree-i-1] = d2
	}

	f := mpc.EBitsPrefixOR(e)

	g := make([]*paillier.Ciphertext, degree)
	g[0] = f[0]
	for i := degree - 1; i > 0; i-- {
		g[i] = mpc.Pk.ESub(f[i], f[i-1])
	}

	h := make([]*paillier.Ciphertext, degree)
	for i := 0; i < degree; i++ {
		h[i] = mpc.EMult(g[degree-i-1], b[i])
	}

	res := mpc.Pk.EncryptInt(big.NewInt(0))

	for i := 0; i < degree; i++ {
		res = mpc.Pk.EAdd(res, h[i])
	}

	return res
}

func (mpc *MPC) EBitsCarries(a, b []*paillier.Ciphertext) []*paillier.Ciphertext {

	//fmt.Println("[DEBUG]:  EBitsCarries()")

	if len(a) < len(b) {
		a = mpc.makeEqualLength(a, b)
	} else {
		b = mpc.makeEqualLength(b, a)
	}

	one := mpc.Pk.EncryptInt(big.NewInt(1))
	degree := len(a) // len(a) = len(b) now

	s := make([]*paillier.Ciphertext, degree)
	p := make([]*paillier.Ciphertext, degree)
	k := make([]*paillier.Ciphertext, degree)
	spks := make([]*spk, degree)

	for i := 0; i < degree; i++ {
		mul := mpc.EMult(a[i], b[i])
		s[i] = mul
	}

	for i := 0; i < degree; i++ {
		// compute propagate bit
		d := mpc.Pk.EAdd(a[i], b[i])
		p[i] = mpc.Pk.ESub(d, mpc.Pk.ECMult(s[i], big.NewInt(2)))

		// compute kill bit
		d = mpc.Pk.EAdd(s[i], p[i])
		k[i] = mpc.Pk.ESub(one, d)

		spks[i] = &spk{s: s[i], p: p[i], k: k[i]}
	}

	f := mpc.EBitsPrefixSPK(spks)

	res := make([]*paillier.Ciphertext, degree)

	for i := 0; i < degree; i++ {
		res[i] = f[i].s
	}

	return res
}

func (mpc *MPC) makeEqualLength(a, b []*paillier.Ciphertext) []*paillier.Ciphertext {
	zero := mpc.Pk.EncryptInt(big.NewInt(0))
	delta := len(b) - len(a)
	zeroArray := make([]*paillier.Ciphertext, delta)
	for i := 0; i < delta; i++ {
		zeroArray[i] = zero
	}

	return append(a, zeroArray...)
}

func (mpc *MPC) EBitsSPK(tups []*spk) *spk {

	//fmt.Println("[DEBUG]:  bitsSPK()")

	size := len(tups)

	b := tups[0].p
	for i := 1; i < size; i++ {
		b = mpc.EMult(b, tups[i].p) // equiv to AND operation
	}

	allPs := make([]*paillier.Ciphertext, size)
	for i := 0; i < size; i++ {
		allPs[i] = tups[size-i-1].p
	}

	preAnd := mpc.ReverseBits(mpc.EFanInMULT(allPs))

	carries := make([]*paillier.Ciphertext, size)
	carries[size-1] = tups[size-1].k

	var wg sync.WaitGroup
	wg.Add(size - 1)
	for i := 0; i < size-1; i++ {
		go func(i int) {
			defer wg.Done()
			mul := mpc.EMult(tups[i].k, preAnd[i+1]) // equiv to AND operation
			carries[i] = mul
		}(i)
	}

	wg.Wait()

	zero := mpc.Pk.EncryptInt(big.NewInt(0))
	one := mpc.Pk.EncryptInt(big.NewInt(1))

	sum := zero
	for i := 0; i < size; i++ {
		sum = mpc.Pk.EAdd(sum, carries[i])
	}

	diff := mpc.Pk.EAdd(b, sum)
	a := mpc.Pk.ESub(one, diff)

	return &spk{s: a, p: b, k: sum}
}

func (mpc *MPC) ReverseBits(bits []*paillier.Ciphertext) []*paillier.Ciphertext {

	size := len(bits)
	bitsR := make([]*paillier.Ciphertext, size)
	for i := 0; i < size; i++ {
		bitsR[size-i-1] = bits[i]
	}

	return bitsR
}

// BitsBigEndian returns the n-bit representation of an integer a
func (mpc *MPC) BitsBigEndian(a *big.Int, n int) []*big.Int {

	s := fmt.Sprintf("%b", a)
	bits := make([]*big.Int, len(s))
	k := 0

	for i := len(s) - 1; i >= 0; i-- {
		bits[k] = big.NewInt(int64(s[i] - '0'))
		k++
	}

	for i := n - len(s); i >= 0; i-- {
		bits = append(bits, big.NewInt(0))
	}

	return bits
}

// EBitsBigEndian returns the n-bit (encrypted) representation of an integer a
func (mpc *MPC) EBitsBigEndian(a *big.Int, n int) []*paillier.Ciphertext {

	s := fmt.Sprintf("%b", a)
	bits := make([]*paillier.Ciphertext, len(s))
	k := 0
	for i := len(s) - 1; i >= 0; i-- {
		bits[k] = mpc.Pk.EncryptInt(big.NewInt(int64(s[i] - '0')))
		k++
	}

	zero := mpc.Pk.EncryptInt(big.NewInt(0))
	for i := n - len(s) - 1; i >= 0; i-- {
		bits = append(bits, zero)
	}

	return bits
}

// EBitsZero returns the n-bit vector of zeros
func (mpc *MPC) EBitsZero() []*paillier.Ciphertext {

	n := mpc.Pk.T.BitLen()
	bits := make([]*paillier.Ciphertext, n)
	zero := mpc.Pk.EncryptInt(big.NewInt(0))

	for i := 0; i < n; i++ {
		bits[i] = zero
	}

	return bits
}

//EBitsTruncPR truncates a bitwise sharing where the last bit is
// probabilistically rounded up or down
func (mpc *MPC) EBitsTruncPR(a *paillier.Ciphertext, k, m int) *paillier.Ciphertext {

	// get 2^k-1 + a
	b := mpc.Pk.EncryptInt(big.NewInt(0).Exp(big2, big.NewInt(int64(k-1)), nil))
	b = mpc.Pk.EAdd(b, a)

	// 2^m
	big2m := big.NewInt(0).Exp(big2, big.NewInt(int64(m)), nil)
	big2mInv := big.NewInt(0).ModInverse(big2m, mpc.Pk.N)

	// get solved bits
	_, r, _ := mpc.solvedBits(m)

	exp := big.NewInt(0).Exp(big2, big.NewInt(int64(mpc.Pk.S+k-m)), nil)
	rnd := mpc.RandomShare(exp)

	// 2^m*rnd + r
	mask := mpc.Pk.ECMult(rnd, big2m)
	mask = mpc.Pk.EAdd(mask, r)

	c := mpc.RevealInt(mpc.Pk.EAdd(b, mask))
	c = c.Mod(c, big2m)

	res := mpc.Pk.EncryptInt(c)
	res = mpc.Pk.ESub(res, r)
	res = mpc.Pk.ESub(a, res)
	res = mpc.Pk.ECMult(res, big2mInv)

	return res
}

// EBitsNormalize returns a tuple (a, v) such that a/2^v is between 0.5 and 1
func (mpc *MPC) EBitsNormalize(a *paillier.Ciphertext) (*paillier.Ciphertext, *paillier.Ciphertext) {

	bitsa := mpc.ReverseBits(mpc.EIntegerToEBits(a))
	ybits := mpc.ReverseBits(mpc.EBitsPrefixOR(bitsa))

	for i := 0; i < mpc.Pk.K-1; i++ {
		ybits[i] = mpc.Pk.ESub(ybits[i], ybits[i+1])
	}

	v := mpc.Pk.EncryptInt(big.NewInt(0))
	pow := big.NewInt(0).Exp(big.NewInt(2), big.NewInt(int64(mpc.Pk.K-1)), nil)

	for i := 0; i < mpc.Pk.K; i++ {
		t := mpc.Pk.ECMult(ybits[i], pow)
		v = mpc.Pk.EAdd(v, t)
		pow.Div(pow, big.NewInt(2))
	}

	u := mpc.EMult(a, v)
	//u = mpc.EBitsTruncPR(u, mpc.Pk.K, mpc.Pk.K-mpc.Pk.FPPrecBits)

	return u, v
}

//EFPFanInMULT returns the vector containing powers of a from 1 ... pow
func (mpc *MPC) EFPFanInMULT(a *paillier.Ciphertext, exp int) []*paillier.Ciphertext {

	res := make([]*paillier.Ciphertext, exp)
	res[0] = a

	// todo make parallel and efficient
	for i := 1; i < exp; i++ {

		c := mpc.EMult(res[i-1], a)
		res[i] = mpc.EBitsTruncPR(c, 2*mpc.Pk.K, mpc.Pk.FPPrecBits)
	}

	return res
}

func (mpc *MPC) EFPInitReciprocal(b *paillier.Ciphertext) *paillier.Ciphertext {

	// init goldschmidt constant
	alpha := mpc.Pk.EncryptInt(mpc.Pk.EncodeFixedPoint(big.NewFloat(2.9142), mpc.Pk.K))

	// normalize the denominator
	u, v := mpc.EBitsNormalize(b)

	// d = alpha - 2u
	d := mpc.Pk.ESub(alpha, mpc.Pk.ECMult(u, big.NewInt(2)))

	// w = d*b
	w := mpc.EMult(d, v)

	// return the normalize initial approximation
	w = mpc.EBitsTruncPR(w, 2*mpc.Pk.K, 2*(mpc.Pk.K-mpc.Pk.FPPrecBits))

	return w
}

//EFPReciprocal return an approximation of [1/b]
func (mpc *MPC) EFPReciprocal(b *paillier.Ciphertext) *paillier.Ciphertext {

	a := mpc.Pk.EncryptInt(mpc.Pk.EncodeFixedPoint(big.NewFloat(1.0), mpc.Pk.FPPrecBits))
	return mpc.EFPDivision(a, b)
}

// EFPDivision return the approximate result of [a/b]
func (mpc *MPC) EFPDivision(a, b *paillier.Ciphertext) *paillier.Ciphertext {

	// init goldschmidt constants
	theta := int(math.Ceil(math.Log2(float64(mpc.Pk.K) / 3.75)))
	alphaEnc := mpc.Pk.EncryptInt(mpc.Pk.EncodeFixedPoint(big.NewFloat(1.0), 2*mpc.Pk.FPPrecBits))

	w := mpc.EFPInitReciprocal(b)

	// x = theta - bw
	x := mpc.Pk.ESub(alphaEnc, mpc.EMult(b, w))

	// y = a*w
	y := mpc.EMult(a, w)
	y = mpc.EBitsTruncPR(y, 2*mpc.Pk.K, mpc.Pk.FPPrecBits)

	fmt.Println("y_0 = " + mpc.RevealInt(y).String())

	for i := 0; i < theta; i++ {

		// y = y * (alpha + x)
		y = mpc.EMult(y, mpc.Pk.EAdd(alphaEnc, x))
		y = mpc.EBitsTruncPR(y, 2*mpc.Pk.K, 2*mpc.Pk.FPPrecBits)

		if i+1 < theta {
			x = mpc.EMult(x, x)
			x = mpc.EBitsTruncPR(x, 2*mpc.Pk.K, 2*mpc.Pk.FPPrecBits)
		}
	}

	return y
}
