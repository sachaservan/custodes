package secstat

import (
	"errors"
	"fmt"
	"math"
	"math/big"
	"strconv"
	"sync"

	"github.com/Nik-U/pbc"
)

var twoInv *big.Int

// pre-computed solved bits for faster on-line phase
var solvedBits [][]*pbc.Element
var solvedBitsValue []*pbc.Element

var solvedBitsMutex sync.Mutex
var nextSolvedBitsIndex = 0

// store lagrange polynomials to avoid recalculations
var lagrangeCache sync.Map

// when using fmt.sprintf to get binary of big.int
var bitsMutex sync.Mutex

func (mpc *MPC) precomputeSolvedBits(n int) {
	solvedBits = make([][]*pbc.Element, n)
	solvedBitsValue = make([]*pbc.Element, n)

	var wg sync.WaitGroup
	for i := 0; i < n; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			bits, d, err := mpc.solvedBits(false)
			for err != nil {
				fmt.Println("[DEBUG]: solvedBits() aborted.")
				bits, d, err = mpc.solvedBits(false)
			}
			solvedBits[i] = bits
			solvedBitsValue[i] = d
			fmt.Println("Finished generating solved bits")

		}(i)
	}

	wg.Wait()
}

// set/propagate/kill wrapper used in the
// EBitsCarries protocol
type spk struct {
	s, p, k *pbc.Element
}

// RandomShare returns a random encrypted integer
// in {1...pk.N}, jointly generated by all parties
func (mpc *MPC) RandomShare() *pbc.Element {

	shares := make([]*pbc.Element, len(mpc.Parties))

	var wg sync.WaitGroup

	for i := 0; i < len(mpc.Parties); i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()

			share := mpc.Parties[i].getRandomShare(true)
			shares[i] = share

		}(i)
	}

	wg.Wait()

	shareSum := mpc.Pk.EncryptDeterministic(big.NewInt(0))
	for i := 0; i < len(mpc.Parties); i++ {
		shareSum = mpc.Pk.EAddElements(shareSum, shares[i])
	}

	return shareSum
}

// RandomInvertibleShare returns a random encrypted integer
// in {1...pk.N} and its inverse (mod pk.T)
func (mpc *MPC) RandomInvertibleShare() (*pbc.Element, *pbc.Element, error) {

	a := mpc.RandomShare()
	b := mpc.RandomShare()
	c := mpc.DecryptElementMPC(mpc.Pk.EMultElements(a, b), true, false)

	if c.Int64() == 0 {
		return nil, nil, errors.New("abort")
	}

	cInv := big.NewInt(0).ModInverse(c, mpc.Pk.T)
	aInv := mpc.Pk.EMultCElement(b, cInv)

	return a, aInv, nil
}

// RandomBit returns a random bit from {0,1}
func (mpc *MPC) RandomBit() (*pbc.Element, error) {

	// fmt.Println("[DEBUG]:  RandomBit()")

	r := mpc.RandomShare()
	a := mpc.DecryptElementMPC(mpc.Pk.EMultElements(r, r), true, false)

	// make sure inverse exists
	if a.Int64() == 0 {
		return nil, errors.New("abort")
	}

	b := big.NewInt(0).ModSqrt(a, mpc.Pk.T)
	bInv := big.NewInt(0).ModInverse(b, mpc.Pk.T) // find b^-1 mod T

	twoInv = big.NewInt(0).ModInverse(big.NewInt(2), mpc.Pk.T) // find 2^-1 mod T

	c := mpc.Pk.EMultCElement(r, bInv)
	c = mpc.Pk.EAddElements(c, mpc.Pk.EncryptDeterministic(big.NewInt(1)))
	c = mpc.Pk.EMultCElement(c, twoInv)

	return c, nil
}

// solvedBits returns a random bit string from {0,1}^n and the corresponding
// integer value from {0...T}
func (mpc *MPC) solvedBits(precomputed bool) ([]*pbc.Element, *pbc.Element, error) {

	if precomputed {
		solvedBitsMutex.Lock()
		if precomputed && solvedBits != nil && nextSolvedBitsIndex > len(solvedBits) {

			bits := solvedBits[nextSolvedBitsIndex]
			val := solvedBitsValue[nextSolvedBitsIndex]
			nextSolvedBitsIndex++
			solvedBitsMutex.Unlock()

			return bits, val, nil
		}
		solvedBitsMutex.Unlock()
	}

	n := mpc.Pk.T.BitLen()
	bits := make([]*pbc.Element, n)

	var wg sync.WaitGroup

	for i := 0; i < n; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()

			bit, err := mpc.RandomBit()
			// err if protocol aborts; a low probability event
			for err != nil {
				fmt.Println("[DEBUG]: RandomBit() aborted.")
				bit, err = mpc.RandomBit()
			}

			bits[i] = bit
		}(i)
	}

	wg.Wait()

	// largest value in bit form log(T) bits
	maxBits := mpc.EBitsBigEndian(mpc.Pk.T, n)

	// picked random bits should evaluate to less
	// than T otherwise no equivalent in integer space
	bad := mpc.EBitsLessThan(bits, maxBits)
	if mpc.DecryptElementMPC(bad, true, true).Int64() == 0 {
		return nil, nil, errors.New("abort")
	}

	// compute the represented integer
	val := mpc.EBitsToEInteger(bits, false)

	return bits, val, nil
}

//EBitsExp returns 2^x where x = integer(bits)
func (mpc *MPC) EBitsExp(bits []*pbc.Element) *pbc.Element {

	base := big.NewInt(2)

	one := mpc.Pk.EncryptDeterministic(big.NewInt(1))

	res := mpc.Pk.EncryptDeterministic(big.NewInt(1))

	for i := 0; i < len(bits); i++ {

		pow := mpc.Pk.EMultCElement(bits[i], base)
		t1 := mpc.Pk.EMultElements(res, pow)

		t2 := mpc.Pk.EMultElements(mpc.Pk.ESubElements(one, bits[i]), one)
		t2 = mpc.Pk.EMultElements(mpc.ReEncryptElementMPC(t2), res)

		res = mpc.Pk.EAddL2Elements(t1, t2)
		res = mpc.ReEncryptElementMPC(res)

		base = base.Exp(base, big.NewInt(2), mpc.Pk.T)

	}
	return res
}

//EBitsToEInteger returns the integer (in Zn) representation of an encrypted binary string
func (mpc *MPC) EBitsToEInteger(bits []*pbc.Element, l2 bool) *pbc.Element {

	if l2 {
		acc := mpc.Pk.ToDeterministicL2Element(mpc.Pk.EncryptDeterministic(big.NewInt(0)))
		base := big.NewInt(2)
		for i := len(bits) - 1; i >= 0; i-- {
			acc = mpc.Pk.EMultCElementL2(acc, base)
			acc = mpc.Pk.EAddL2Elements(acc, bits[i])
		}
		return acc

	}

	acc := mpc.Pk.EncryptDeterministic(big.NewInt(0))
	base := big.NewInt(2)
	for i := len(bits) - 1; i >= 0; i-- {
		acc = mpc.Pk.EMultCElement(acc, base)
		acc = mpc.Pk.EAddElements(acc, bits[i])
	}
	return acc
}

// EIntegerToEBits returns a bit representation of an integer in {0...T}
func (mpc *MPC) EIntegerToEBits(a *pbc.Element) []*pbc.Element {

	//fmt.Println("[DEBUG]:  EBits()")

	n := mpc.Pk.T.BitLen() + 1
	// max value in integers < T
	maxValue := big.NewInt(0).Exp(big.NewInt(2), big.NewInt(int64(n+1)), nil)

	// max value in encrypted dummy bit form
	maxEBits := mpc.EBitsBigEndian(mpc.Pk.T, n)

	// diff 2^log(T) - T note that this has to be a positive quantity
	deltaBits := mpc.BitsBigEndian(big.NewInt(0).Sub(maxValue, mpc.Pk.T), n)

	// get solved bits
	solvedBits, d, err := mpc.solvedBits(true)
	for err != nil {
		fmt.Println("[DEBUG]: solvedBits() aborted.")
		solvedBits, d, err = mpc.solvedBits(false)
	}

	// compute a-d where d is the integer returned from solvedbits
	rev := mpc.DecryptElementMPC(mpc.Pk.ESubElements(a, d), false, false)
	revBits := mpc.EBitsBigEndian(rev, n)
	sumBits := mpc.EBitsADD(revBits, solvedBits)
	sumBits = sumBits[0 : len(sumBits)-1]

	q := mpc.ReEncryptElementMPC(mpc.EBitsLessThan(maxEBits, sumBits))
	g := make([]*pbc.Element, n)

	for i := 0; i < n; i++ {
		g[i] = mpc.Pk.EMultCElement(q, deltaBits[i])
	}

	h := mpc.EBitsADD(sumBits, g)

	// drop the two most significant bits to correct error
	// see paper for details
	return h[0 : len(h)-1]
}

// EFanInMULT efficiently computes [x,x^2,x^3...x^n] where n = len(elements)
// Note: can be used as a PrefixAND when elements are binary
func (mpc *MPC) EFanInMULT(elements []*pbc.Element) []*pbc.Element {

	// fmt.Println("[DEBUG]: EFanInMULT()")

	n := len(elements)
	res := make([]*pbc.Element, n)
	res[0] = elements[0]

	if n == 1 {
		return res
	}

	powerMult := mpc.Pk.EMultElements(elements[0], elements[1])
	powerMult = mpc.ReEncryptElementMPC(powerMult)

	for i := 1; i < n; i++ {
		res[i] = powerMult
		// avoid unnecessary computation
		if i+1 < n {
			powerMult = mpc.Pk.EMultElements(powerMult, elements[i+1])
			powerMult = mpc.ReEncryptElementMPC(powerMult)
		}
	}

	return res
}

// EBitsOR computes the OR of all the bits
func (mpc *MPC) EBitsOR(bits []*pbc.Element) *pbc.Element {

	//fmt.Println("[DEBUG]:  EBitsOR()")

	n := len(bits)

	sum := mpc.Pk.EncryptDeterministic(big.NewInt(1))
	for i := 0; i < n; i++ {
		sum = mpc.Pk.EAddElements(sum, bits[i])
	}

	a := make([]*pbc.Element, n+1)
	for i := 0; i <= n; i++ {
		a[i] = sum
	}

	mul := mpc.EFanInMULT(a)
	a = mul

	poly := binaryORFunctionInterpolation(n, mpc.Pk.T)
	res := mpc.Pk.EncryptDeterministic(big.NewInt(0).Add(poly[n], big.NewInt(1)))
	for i := 1; i <= n; i++ {
		c := mpc.Pk.EMultCElement(a[i-1], poly[n-i])
		res = mpc.Pk.EAddElements(res, c)
	}

	return res
}

// EBitsAND computes the AND of all the bits
func (mpc *MPC) EBitsAND(bits []*pbc.Element) *pbc.Element {

	//fmt.Println("[DEBUG]:  EBitsAND()")

	degree := len(bits)

	res := bits[0]
	for i := 1; i < degree; i++ {
		c := mpc.Pk.EMultElements(res, bits[i])
		res = mpc.ReEncryptElementMPC(c)
	}

	return res
}

func (mpc *MPC) EBitsPrefixOR(bits []*pbc.Element) []*pbc.Element {

	//fmt.Println("[DEBUG]:  EBitsPrefixOR()")

	degree := len(bits)

	// find the nearest square to len(bits)
	lambda := int(math.Ceil(math.Sqrt(float64(len(bits)))))
	zero := mpc.Pk.EncryptDeterministic(big.NewInt(0))

	diff := lambda*lambda - len(bits)
	for i := 0; i < diff; i++ {
		bits = append(bits, zero)
	}

	var wg sync.WaitGroup
	// Compute Row wise OR of elements in A
	rowOr := make([]*pbc.Element, lambda)
	for i := 0; i < lambda; i++ {
		wg.Add(1)
		row := make([]*pbc.Element, lambda)
		for j := 0; j < lambda; j++ {
			row[j] = bits[i*lambda+j]
		}

		go func(i int, row []*pbc.Element) {
			defer wg.Done()

			res := mpc.EBitsOR(row)
			rowOr[i] = res

		}(i, row)
	}

	wg.Wait()

	// Compute ORs of Xis
	rowRes := make([]*pbc.Element, lambda)
	rowRes[0] = rowOr[0]

	wg.Add(lambda - 1)
	for n := 1; n < lambda; n++ {

		row := make([]*pbc.Element, n+1)
		for i := 0; i <= n; i++ {
			row[i] = rowOr[i]
		}

		go func(n int, row []*pbc.Element) {
			defer wg.Done()

			res := mpc.EBitsOR(row)
			rowRes[n] = res

		}(n, row)
	}

	wg.Wait()

	f := make([]*pbc.Element, lambda)
	f[0] = rowOr[0]
	for i := 1; i < lambda; i++ {
		f[i] = mpc.Pk.ESubElements(rowRes[i], rowRes[i-1])
	}

	g := make([]*pbc.Element, lambda)
	for j := 0; j < lambda; j++ {
		sum := mpc.Pk.ToDeterministicL2Element(zero)
		for i := 0; i < lambda; i++ {
			sum = mpc.Pk.EAddL2Elements(sum, mpc.Pk.EMultElements(bits[i*lambda+j], f[i]))
		}
		g[j] = mpc.ReEncryptElementMPC(sum)

	}

	// Compute PrefixOr of ci
	b := make([]*pbc.Element, lambda)
	b[0] = g[0]

	wg.Add(lambda - 1)
	for n := 1; n < lambda; n++ {

		row := make([]*pbc.Element, n+1)
		for i := 0; i <= n; i++ {
			row[i] = g[i]
		}

		go func(n int, row []*pbc.Element) {
			defer wg.Done()

			res := mpc.EBitsOR(row)
			b[n] = res

		}(n, row)
	}

	wg.Wait()

	s := make([]*pbc.Element, lambda)
	for i := 0; i < lambda; i++ {
		s[i] = mpc.Pk.ESubElements(rowRes[i], f[i])
	}

	result := make([]*pbc.Element, lambda*lambda)
	for i := 0; i < lambda; i++ {
		for j := 0; j < lambda; j++ {

			if lambda*i+j >= degree {
				break
			}

			sum := mpc.Pk.EMultElements(b[j], f[i])
			sum = mpc.Pk.EAddL2Elements(sum, mpc.Pk.ToDeterministicL2Element(s[i]))

			res := mpc.ReEncryptElementMPC(sum)

			result[i*lambda+j] = res
		}
	}

	return result[0:degree]
}

func (mpc *MPC) EBitsPrefixSPK(bits []*spk) []*spk {

	// TODO: make this faster
	degree := len(bits)

	var wg sync.WaitGroup
	wg.Add(degree)

	res := make([]*spk, degree)
	for i := 0; i < degree; i++ {

		row := make([]*spk, i+1)
		for k := 0; k <= i; k++ {
			row[k] = bits[k]
		}

		go func(i int, row []*spk) {
			defer wg.Done()

			spk := mpc.bitsSPK(row)
			res[i] = spk

		}(i, row)
	}

	wg.Wait()

	return res
}

func (mpc *MPC) EBitsADD(a, b []*pbc.Element) []*pbc.Element {

	if len(a) < len(b) {
		a = mpc.makeEqualLength(a, b)
	} else {
		b = mpc.makeEqualLength(b, a)
	}

	degree := len(a)
	carries := mpc.EBitsCarries(a, b)

	sum := make([]*pbc.Element, degree+1)
	lsb := mpc.Pk.EAddElements(a[0], b[0])
	lsb = mpc.Pk.ESubElements(lsb, mpc.Pk.EMultCElement(carries[0], big.NewInt(2)))
	sum[0] = lsb
	sum[degree] = carries[degree-1]

	for i := 1; i < degree; i++ {
		sum[i] = mpc.Pk.EAddElements(a[i], b[i])
		sum[i] = mpc.Pk.EAddElements(sum[i], carries[i-1])
		sum[i] = mpc.Pk.ESubElements(sum[i], mpc.Pk.EMultCElement(carries[i], big.NewInt(2)))
	}

	return sum
}

func (mpc *MPC) EBitsLessThan(a, b []*pbc.Element) *pbc.Element {

	//fmt.Println("[DEBUG]:  EBitsLessThan()")

	if len(a) < len(b) {
		a = mpc.makeEqualLength(a, b)
	} else {
		b = mpc.makeEqualLength(b, a)
	}

	degree := len(a) // len(a) = len(b) now
	e := make([]*pbc.Element, degree)

	for i := 0; i < degree; i++ {
		d := mpc.Pk.ESubElements(a[i], b[i])
		d2 := mpc.Pk.EMultElements(d, d)
		e[degree-i-1] = mpc.ReEncryptElementMPC(d2)
	}

	f := mpc.EBitsPrefixOR(e)

	g := make([]*pbc.Element, degree)
	g[0] = f[0]
	for i := degree - 1; i > 0; i-- {
		g[i] = mpc.Pk.ESubElements(f[i], f[i-1])
	}

	h := make([]*pbc.Element, degree)
	for i := 0; i < degree; i++ {
		h[i] = mpc.Pk.EMultElements(g[degree-i-1], b[i])
	}

	res := mpc.Pk.ToDeterministicL2Element(mpc.Pk.EncryptDeterministic(big.NewInt(0)))

	for i := 0; i < degree; i++ {
		res = mpc.Pk.EAddL2Elements(res, h[i])
	}

	return res
}

func (mpc *MPC) EBitsCarries(a, b []*pbc.Element) []*pbc.Element {

	//fmt.Println("[DEBUG]:  EBitsCarries()")

	if len(a) < len(b) {
		a = mpc.makeEqualLength(a, b)
	} else {
		b = mpc.makeEqualLength(b, a)
	}

	one := mpc.Pk.EncryptDeterministic(big.NewInt(1))
	degree := len(a) // len(a) = len(b) now

	s := make([]*pbc.Element, degree)
	p := make([]*pbc.Element, degree)
	k := make([]*pbc.Element, degree)
	spks := make([]*spk, degree)

	for i := 0; i < degree; i++ {
		mul := mpc.Pk.EMultElements(a[i], b[i])
		s[i] = mpc.ReEncryptElementMPC(mul)
	}

	for i := 0; i < degree; i++ {
		// compute propagate bit
		d := mpc.Pk.EAddElements(a[i], b[i])
		p[i] = mpc.Pk.ESubElements(d, mpc.Pk.EMultCElement(s[i], big.NewInt(2)))

		// compute kill bit
		d = mpc.Pk.EAddElements(s[i], p[i])
		k[i] = mpc.Pk.ESubElements(one, d)

		spks[i] = &spk{s: s[i], p: p[i], k: k[i]}
	}

	f := mpc.EBitsPrefixSPK(spks)

	res := make([]*pbc.Element, degree)

	for i := 0; i < degree; i++ {
		res[i] = f[i].s
	}

	return res
}

func (mpc *MPC) makeEqualLength(a, b []*pbc.Element) []*pbc.Element {
	zero := mpc.Pk.EncryptDeterministic(big.NewInt(0))
	delta := len(b) - len(a)
	zeroArray := make([]*pbc.Element, delta)
	for i := 0; i < delta; i++ {
		zeroArray[i] = zero
	}

	return append(a, zeroArray...)
}

func (mpc *MPC) bitsSPK(tups []*spk) *spk {

	//fmt.Println("[DEBUG]:  bitsSPK()")

	size := len(tups)

	b := tups[0].p
	for i := 1; i < size; i++ {
		c := mpc.Pk.EMultElements(b, tups[i].p) // equiv to AND operation
		b = mpc.ReEncryptElementMPC(c)
	}

	allPs := make([]*pbc.Element, size)
	for i := 0; i < size; i++ {
		allPs[i] = tups[size-i-1].p
	}

	preAnd := mpc.ReverseBits(mpc.EFanInMULT(allPs))

	carries := make([]*pbc.Element, size)
	carries[size-1] = mpc.Pk.ToDeterministicL2Element(tups[size-1].k)

	var wg sync.WaitGroup
	wg.Add(size - 1)
	for i := 0; i < size-1; i++ {
		go func(i int) {
			defer wg.Done()
			mul := mpc.Pk.EMultElements(tups[i].k, preAnd[i+1]) // equiv to AND operation
			carries[i] = mul
		}(i)
	}

	wg.Wait()

	zero := mpc.Pk.EncryptDeterministic(big.NewInt(0))
	one := mpc.Pk.EncryptDeterministic(big.NewInt(1))

	sum := mpc.Pk.ToDeterministicL2Element(zero)
	for i := 0; i < size; i++ {
		sum = mpc.Pk.EAddL2Elements(sum, carries[i])
	}

	b = mpc.Pk.ToDeterministicL2Element(b)
	diff := mpc.Pk.EAddL2Elements(b, sum)
	a := mpc.Pk.ESubL2Elements(mpc.Pk.ToDeterministicL2Element(one), diff)
	a = mpc.ReEncryptElementMPC(a)

	return &spk{s: a, p: b, k: sum}
}

func (mpc *MPC) ReverseBits(bits []*pbc.Element) []*pbc.Element {

	size := len(bits)
	bitsR := make([]*pbc.Element, size)
	for i := 0; i < size; i++ {
		bitsR[size-i-1] = bits[i]
	}

	return bitsR
}

// BitsBigEndian returns the n-bit representation of an integer a
func (mpc *MPC) BitsBigEndian(a *big.Int, n int) []*big.Int {

	bitsMutex.Lock()
	s := strconv.FormatInt(a.Int64(), 2)
	bits := make([]*big.Int, len(s))
	k := 0

	for i := len(s) - 1; i >= 0; i-- {
		bits[k] = big.NewInt(int64(s[i] - '0'))
		k++
	}

	for i := n - len(s); i >= 0; i-- {
		bits = append(bits, big.NewInt(0))
	}

	bitsMutex.Unlock()

	return bits
}

// EBitsBigEndian returns the n-bit (encrypted) representation of an integer a
func (mpc *MPC) EBitsBigEndian(a *big.Int, n int) []*pbc.Element {

	bitsMutex.Lock()

	s := strconv.FormatInt(a.Int64(), 2)
	bits := make([]*pbc.Element, len(s))
	k := 0
	for i := len(s) - 1; i >= 0; i-- {
		bits[k] = mpc.Pk.EncryptDeterministic(big.NewInt(int64(s[i] - '0')))
		k++
	}

	zero := mpc.Pk.EncryptDeterministic(big.NewInt(0))
	for i := n - len(s) - 1; i >= 0; i-- {
		bits = append(bits, zero)
	}

	bitsMutex.Unlock()

	return bits
}

// EBitsZero returns the n-bit vector of zeros
func (mpc *MPC) EBitsZero() []*pbc.Element {

	n := mpc.Pk.T.BitLen()
	bits := make([]*pbc.Element, n)
	zero := mpc.Pk.EncryptDeterministic(big.NewInt(0))

	for i := 0; i < n; i++ {
		bits[i] = zero
	}

	return bits
}

func neg(a *big.Int, p *big.Int) *big.Int {
	return big.NewInt(0).Sub(p, a)
}

func (mpc *MPC) computeLangragePolynomialCache(n int) {

	for i := 0; i < n; i++ {
		binaryORFunctionInterpolation(i, mpc.Pk.T)
	}
}

// compute the lagrange interpolation of the function such that
// f(1) = 0, f(1) = f(2) = f(3).... = 1
func binaryORFunctionInterpolation(n int, p *big.Int) []*big.Int {

	// fmt.Println("[DEBUG]: binaryORFunctionInterpolation()")

	if value, found := lagrangeCache.Load(n); found {
		if v, ok := value.([]*big.Int); ok {
			out := make([]*big.Int, n+1)
			for i := 0; i <= n; i++ {
				out[i] = big.NewInt(0).Set(v[i])
			}
			return out
		}
	}

	//fmt.Println("[DEBUG]: binaryORFunctionInterpolation()")

	var numerator []*big.Int
	var poly []*big.Int

	denom := big.NewInt(1)
	poly = make([]*big.Int, n)

	for k := 0; k < n; k++ {
		poly[k] = big.NewInt(0)
	}

	for i := 1; i <= n; i++ {
		for j := 0; j <= n; j++ {
			if i != j {
				xi := big.NewInt(int64(i + 1))
				xj := big.NewInt(int64(j + 1))

				if numerator == nil {
					numerator = []*big.Int{big.NewInt(1), neg(xi, p)}
				} else {
					numerator = polyMult(numerator, []*big.Int{big.NewInt(1), neg(xj, p)})
				}

				denom.Mul(denom, big.NewInt(0).Add(xi, neg(xj, p)))
			}
		}

		if big.NewInt(0).Abs(denom).Cmp(big.NewInt(1)) != 0 {
			denom = denom.ModInverse(denom, p)
		}

		for i := 0; i < len(numerator); i++ {
			numerator[i].Mul(numerator[i], denom)
		}

		poly = polyAdd(poly, numerator)

		// reset
		denom = big.NewInt(1)
		numerator = nil

	}

	for i := 0; i < len(poly); i++ {
		if poly[i].Cmp(big.NewInt(0)) < 0 {
			poly[i] = poly[i].Neg(poly[i])
			poly[i] = poly[i].Mod(poly[i], p)
			poly[i] = neg(poly[i], p)
		} else {
			poly[i] = poly[i].Mod(poly[i], p)
		}
	}

	lagrangeCache.Store(n, poly)

	return poly
}

func polyMult(poly1 []*big.Int, poly2 []*big.Int) []*big.Int {
	n := len(poly1) + len(poly2)
	result := make([]*big.Int, n)
	for k := 0; k < n; k++ {
		result[k] = big.NewInt(0)
	}

	for i, coefficient := range poly1 {
		for j, coefficient2 := range poly2 {
			result[i+j].Add(result[i+j], big.NewInt(0).Mul(coefficient, coefficient2))
		}
	}
	return result[0 : n-1]
}

func polyAdd(poly1 []*big.Int, poly2 []*big.Int) []*big.Int {
	len1 := len(poly1)
	len2 := len(poly2)

	result := make([]*big.Int, len1)

	if len1 >= len2 {
		for i := 0; i < len1-len2; i++ {
			result[i] = poly1[i]
		}

		k := 0
		for i := len1 - len2; i < len1; i++ {
			result[i] = big.NewInt(0).Add(poly1[i], poly2[k])
			k++
		}

	} else {
		result = polyAdd(poly2, poly1)
	}

	return result

}
